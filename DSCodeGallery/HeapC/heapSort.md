## 堆排序（Heap Sort）

堆排序是一种高效的比较排序算法，它具有稳定的 O(n log n) 时间复杂度，适用于大规模数据集。以下是堆排序的详细解释。

### 1. 堆排序算法步骤

堆排序算法主要包括两个步骤：建堆和排序。

#### 1.1 建堆（Build Heap）

- **目标**：将原始数组构建成一个堆，确保满足堆的性质。
- **实现**：从数组的最后一个非叶子节点开始，依次向前调用 `adjust_down` 操作，将节点逐步下沉，以确保整个数组满足最大堆性质。
- **时间复杂度**：O(n)

#### 1.2 排序

- **目标**：排序数组，将最大值移到数组的末尾，然后逐渐减小堆的大小，重复操作，直到排序完成。
- **实现**：反复执行以下步骤：
    1. 交换堆顶元素（最大值）与当前堆的最后一个元素。
    2. 减小堆的大小，排除最大值。
    3. 调用 `adjust_down` 操作将新的堆顶元素下沉，以维持最大堆性质。
- **时间复杂度**：O(n log n)

### 2. 堆排序的时间复杂度

- 建堆阶段的时间复杂度：O(n)
- 排序阶段的时间复杂度：O(n log n)
- 总体时间复杂度：O(n + n log n) = O(n log n)

### 3. 堆排序的特点

- 不稳定排序：堆排序是一种不稳定的排序算法，相同元素的相对顺序可能会改变。
- 原地排序：堆排序是一种原地排序算法，不需要额外的空间。
- 时间复杂度：堆排序的平均和最坏情况时间复杂度均为 O(n log n)。
- 适用性：堆排序适用于大规模数据集，但由于其不稳定性和比较次数较多，对小规模数据集不如快速排序。

### 4. 堆排序的实现

以下是堆排序的代码示例：

```c
void heapSort(pointer arr, size_type size) {

    // 向上建堆(O(NlogN))
//    for(int index = 1; index < size; ++index) {
//        adjust_up(arr, index);
//    }

    // 构建最大堆（向下建堆）(O(N))
    for (int index = (size - 1 - 1) / 2; index >= 0; index--) {
        adjust_down(arr, index, size);
    }

    // 排序
    for (int index = size - 1; index > 0; index--) {
        // 交换堆顶元素（最大值）与当前堆的最后一个元素
        swap(&arr[0], &arr[index]);

        // 减小堆的大小，排除最大值
        adjust_down(arr, 0, index);
    }
}
```

这是一个完整的堆排序算法的实现，它在建堆阶段和排序阶段分别调用 `adjust_down` 操作，以达到排序的目的。